{"version":3,"file":"index.js","sources":["../src/utils.js","../src/hooks/useTableState.js","../src/hooks/useTable.js","../src/hooks/useColumns.js","../src/hooks/useRows.js","../src/actions.js","../src/hooks/useExpanded.js","../src/hooks/useFilters.js","../src/aggregations.js","../src/hooks/useGroupBy.js","../src/hooks/useSortBy.js","../src/hooks/usePagination.js","../src/hooks/useFlexLayout.js","../src/hooks/useTokenPagination.js"],"sourcesContent":["import React from 'react'\n\nexport function getBy(obj, path, def) {\n  if (!path) {\n    return obj\n  }\n  const pathObj = makePathArray(path)\n  let val\n  try {\n    val = pathObj.reduce((cursor, pathPart) => cursor[pathPart], obj)\n  } catch (e) {\n    // continue regardless of error\n  }\n  return typeof val !== 'undefined' ? val : def\n}\n\nexport function defaultOrderByFn(arr, funcs, dirs) {\n  return [...arr].sort((rowA, rowB) => {\n    for (let i = 0; i < funcs.length; i += 1) {\n      const sortFn = funcs[i]\n      const desc = dirs[i] === false || dirs[i] === 'desc'\n      const sortInt = sortFn(rowA, rowB)\n      if (sortInt !== 0) {\n        return desc ? -sortInt : sortInt\n      }\n    }\n    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index\n  })\n}\n\nexport function defaultSortByFn(a, b, desc) {\n  // force null and undefined to the bottom\n  a = a === null || a === undefined ? '' : a\n  b = b === null || b === undefined ? '' : b\n  // force any string values to lowercase\n  a = typeof a === 'string' ? a.toLowerCase() : a\n  b = typeof b === 'string' ? b.toLowerCase() : b\n  // Return either 1 or -1 to indicate a sort priority\n  if (a > b) {\n    return 1\n  }\n  if (a < b) {\n    return -1\n  }\n  // returning 0, undefined or any falsey value will defer to the next\n  // sorting mechanism or eventually the columns index via the orderByFn\n  return 0\n}\n\nexport function getFirstDefined(...args) {\n  for (let i = 0; i < args.length; i += 1) {\n    if (typeof args[i] !== 'undefined') {\n      return args[i]\n    }\n  }\n}\n\nexport function defaultGroupByFn(rows, grouper) {\n  return rows.reduce((prev, row, i) => {\n    const resKey =\n      typeof grouper === 'function'\n        ? grouper(row.values, i)\n        : row.values[grouper]\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : []\n    prev[resKey].push(row)\n    return prev\n  }, {})\n}\n\nexport function defaultFilterFn(row, id, value, column) {\n  return row.values[id] !== undefined\n    ? String(row.values[id])\n      .toLowerCase()\n      .includes(String(value).toLowerCase())\n    : true\n}\n\nexport function setBy(obj = {}, path, value) {\n  const recurse = (obj, depth = 0) => {\n    const key = path[depth]\n    const target = typeof obj[key] !== 'object' ? {} : obj[key]\n    const subValue =\n      depth === path.length - 1 ? value : recurse(target, depth + 1)\n    return {\n      ...obj,\n      [key]: subValue\n    }\n  }\n\n  return recurse(obj)\n}\n\nexport function getElementDimensions(element) {\n  const rect = element.getBoundingClientRect()\n  const style = window.getComputedStyle(element)\n  const margins = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight)\n  }\n  const padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight)\n  }\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n    outerWidth: Math.ceil(\n      rect.width + margins.left + margins.right + padding.left + padding.right\n    ),\n    marginLeft: margins.left,\n    marginRight: margins.right,\n    paddingLeft: padding.left,\n    paddingRight: padding.right,\n    scrollWidth: element.scrollWidth\n  }\n}\n\nexport function flexRender(Comp, props) {\n  if (typeof Comp === 'function') {\n    return Object.getPrototypeOf(Comp).isReactComponent ? (\n      <Comp {...props} />\n    ) : (\n      Comp(props)\n    )\n  }\n  return Comp\n}\n\nexport const mergeProps = (...groups) => {\n  let props = {}\n  groups.forEach(({ style = {}, className, ...rest } = {}) => {\n    props = {\n      ...props,\n      ...rest,\n      style: {\n        ...(props.style || {}),\n        ...style\n      },\n      className: [props.className, className].filter(Boolean).join(' ')\n    }\n  })\n  return props\n}\n\nexport const applyHooks = (hooks, initial, ...args) =>\n  hooks.reduce((prev, next) => next(prev, ...args), initial)\n\nexport const applyPropHooks = (hooks, ...args) =>\n  hooks.reduce((prev, next) => mergeProps(prev, next(...args)), {})\n\nexport const warnUnknownProps = props => {\n  if (Object.keys(props).length) {\n    throw new Error(\n      `Unknown options passed to useReactTable:\n      \n${JSON.stringify(props, null, 2)}`\n    )\n  }\n}\n\nexport function sum(arr) {\n  return arr.reduce((prev, curr) => prev + curr, 0)\n}\n\nfunction makePathArray(obj) {\n  return flattenDeep(obj)\n    .join('.')\n    .replace(/\\[/g, '.')\n    .replace(/\\]/g, '')\n    .split('.')\n}\n\nfunction flattenDeep(arr, newArr = []) {\n  if (!Array.isArray(arr)) {\n    newArr.push(arr)\n  } else {\n    for (let i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr)\n    }\n  }\n  return newArr\n}\n","import { useState, useMemo } from 'react'\n\nexport const defaultState = {}\n\nconst defaultReducer = (old, newState) => newState\n\nexport const useTableState = (\n  initialState = {},\n  overrides = {},\n  { reducer = defaultReducer, useState: userUseState = useState } = {}\n) => {\n  let [state, setState] = userUseState({\n    ...defaultState,\n    ...initialState\n  })\n  console.log('useTableState', defaultState, initialState, state)\n\n  const overriddenState = useMemo(() => {\n    const newState = {\n      ...state\n    }\n    Object.keys(overrides).forEach((key) => {\n      newState[key] = overrides[key]\n    })\n    return newState\n  }, [state, ...Object.values(overrides)])\n\n  const reducedSetState = (updater, type) =>\n    setState((old) => {\n      const newState = updater(old)\n      return reducer(old, newState, type)\n    })\n\n  return [overriddenState, reducedSetState]\n}\n","import PropTypes from 'prop-types'\n//\nimport { flexRender, applyHooks, applyPropHooks, mergeProps } from '../utils'\n\nimport { useTableState } from './useTableState'\n\nconst renderErr =\n  'You must specify a render \"type\". This could be \"Header\", \"Filter\", or any other custom renderers you have set on your column.'\n\nconst propTypes = {\n  // General\n  data: PropTypes.array.isRequired,\n  defaults: PropTypes.object,\n  debug: PropTypes.bool\n}\n\nexport const useTable = (props, ...plugins) => {\n  // Validate props\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useTable')\n\n  // Destructure props\n  let { data = [], defaults = {}, debug } = props\n\n  debug = process.env.NODE_ENV === 'production' ? false : debug\n\n  // Use defaults from the props as initial values for the state.\n  const state = useTableState(defaults)\n\n  // These are hooks that plugins can use right before render\n  const hooks = {\n    beforeRender: [],\n    columns: [],\n    headers: [],\n    headerGroups: [],\n    rows: [],\n    row: [],\n    renderableRows: [],\n    getTableProps: [],\n    getRowProps: [],\n    getHeaderRowProps: [],\n    getHeaderProps: [],\n    getCellProps: []\n  }\n\n  // The initial api\n  let api = {\n    ...props,\n    data,\n    state,\n    hooks\n  }\n\n  if (debug) console.time('hooks')\n  // Loop through plugins to build the api out\n  api = plugins.filter(Boolean).reduce((prev, next) => next(prev), api)\n  if (debug) console.timeEnd('hooks')\n\n  // Run the beforeRender hook\n  if (debug) console.time('hooks.beforeRender')\n  applyHooks(api.hooks.beforeRender, undefined, api)\n  if (debug) console.timeEnd('hooks.beforeRender')\n\n  if (debug) console.time('hooks.columns')\n  api.columns = applyHooks(api.hooks.columns, api.columns, api)\n  if (debug) console.timeEnd('hooks.columns')\n\n  if (debug) console.time('hooks.headers')\n  api.headers = applyHooks(api.hooks.headers, api.headers, api)\n  if (debug) console.timeEnd('hooks.headers')\n  ;[...api.columns, ...api.headers].forEach((column) => {\n    // Give columns/headers rendering power\n    column.render = (type, userProps = {}) => {\n      if (!type) {\n        throw new Error(renderErr)\n      }\n      return flexRender(column[type], {\n        ...api,\n        ...column,\n        ...userProps\n      })\n    }\n\n    // Give columns/headers getHeaderProps\n    column.getHeaderProps = (props) =>\n      mergeProps(\n        {\n          key: ['header', column.id].join('_')\n        },\n        applyPropHooks(api.hooks.getHeaderProps, column, api),\n        props\n      )\n  })\n\n  if (debug) console.time('hooks.headerGroups')\n  api.headerGroups = applyHooks(\n    api.hooks.headerGroups,\n    api.headerGroups,\n    api\n  ).filter((headerGroup, i) => {\n    // Filter out any headers and headerGroups that don't have visible columns\n    headerGroup.headers = headerGroup.headers.filter((header) => {\n      const recurse = (columns) =>\n        columns.filter((column) => {\n          if (column.columns) {\n            return recurse(column.columns)\n          }\n          return column.visible\n        }).length\n      if (header.columns) {\n        return recurse(header.columns)\n      }\n      return header.visible\n    })\n\n    // Give headerGroups getRowProps\n    if (headerGroup.headers.length) {\n      headerGroup.getRowProps = (props = {}) =>\n        mergeProps(\n          {\n            key: [`header${i}`].join('_')\n          },\n          applyPropHooks(api.hooks.getHeaderRowProps, headerGroup, api),\n          props\n        )\n      return true\n    }\n\n    return false\n  })\n  if (debug) console.timeEnd('hooks.headerGroups')\n\n  // Run the rows (this could be a dangerous hook with a ton of data)\n  if (debug) console.time('hooks.rows')\n  api.rows = applyHooks(api.hooks.rows, api.rows, api)\n  if (debug) console.timeEnd('hooks.rows')\n\n  // This function is absolutely necessary and MUST be called on\n  // any rows the user wishes to be displayed.\n  api.prepareRow = (row) => {\n    const { path } = row\n    row.getRowProps = (props) =>\n      mergeProps(\n        { key: ['row', path].join('_') },\n        applyHooks(api.hooks.getRowProps, row, api),\n        props\n      )\n\n    // need to apply any row specific hooks (useExpanded requires this)\n    applyHooks(api.hooks.row, row, api)\n\n    row.cells = row.cells.filter((cell) => cell.column.visible)\n\n    row.cells.forEach((cell) => {\n      if (!cell) {\n        return\n      }\n\n      const { column } = cell\n\n      cell.getCellProps = (props) => {\n        const columnPathStr = [path, column.id].join('_')\n        return mergeProps(\n          {\n            key: ['cell', columnPathStr].join('_')\n          },\n          applyPropHooks(api.hooks.getCellProps, cell, api),\n          props\n        )\n      }\n\n      cell.render = (type, userProps = {}) => {\n        if (!type) {\n          throw new Error(\n            'You must specify a render \"type\". This could be \"Cell\", \"Header\", \"Filter\", \"Aggregated\" or any other custom renderers you have set on your column.'\n          )\n        }\n        return flexRender(column[type], {\n          ...api,\n          ...cell,\n          ...userProps\n        })\n      }\n    })\n  }\n\n  api.getTableProps = (userProps) =>\n    mergeProps(applyPropHooks(api.hooks.getTableProps, api), userProps)\n\n  api.getRowProps = (userProps) =>\n    mergeProps(applyPropHooks(api.hooks.getRowProps, api), userProps)\n\n  return api\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { getBy } from '../utils'\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      Cell: PropTypes.any,\n      Header: PropTypes.any\n    })\n  )\n}\n\nexport const useColumns = props => {\n  const {\n    debug,\n    columns: userColumns,\n    state: [{ groupBy }]\n  } = props\n\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useColumns')\n\n  const { columns, headerGroups, headers } = useMemo(() => {\n    if (debug) console.info('getColumns')\n\n    // Decorate All the columns\n    let columnTree = decorateColumnTree(userColumns)\n\n    // Get the flat list of all columns\n    let columns = flattenBy(columnTree, 'columns')\n\n    columns = [\n      ...groupBy.map(g => columns.find(col => col.id === g)),\n      ...columns.filter(col => !groupBy.includes(col.id))\n    ]\n\n    // Get headerGroups\n    const headerGroups = makeHeaderGroups(columns, findMaxDepth(columnTree))\n    const headers = flattenBy(headerGroups, 'headers')\n\n    return {\n      columns,\n      headerGroups,\n      headers\n    }\n  }, [groupBy, userColumns])\n\n  return {\n    ...props,\n    columns,\n    headerGroups,\n    headers\n  }\n\n  // Find the depth of the columns\n  function findMaxDepth(columns, depth = 0) {\n    return columns.reduce((prev, curr) => {\n      if (curr.columns) {\n        return Math.max(prev, findMaxDepth(curr.columns, depth + 1))\n      }\n      return depth\n    }, 0)\n  }\n\n  function decorateColumn(column, parent) {\n    // First check for string accessor\n    let { id, accessor, Header } = column\n\n    if (typeof accessor === 'string') {\n      id = id || accessor\n      const accessorString = accessor\n      accessor = row => getBy(row, accessorString)\n    }\n\n    if (!id && typeof Header === 'string') {\n      id = Header\n    }\n\n    if (!id) {\n      // Accessor, but no column id? This is bad.\n      console.error(column)\n      throw new Error('A column id is required!')\n    }\n\n    column = {\n      Header: '',\n      Cell: cell => cell.value,\n      show: true,\n      ...column,\n      id,\n      accessor,\n      parent\n    }\n\n    return column\n  }\n\n  // Build the visible columns, headers and flat column list\n  function decorateColumnTree(columns, parent, depth = 0) {\n    return columns.map(column => {\n      column = decorateColumn(column, parent)\n      if (column.columns) {\n        column.columns = decorateColumnTree(column.columns, column, depth + 1)\n      }\n      return column\n    })\n  }\n\n  function flattenBy(columns, childKey) {\n    const flatColumns = []\n\n    const recurse = columns => {\n      columns.forEach(d => {\n        if (!d[childKey]) {\n          flatColumns.push(d)\n        } else {\n          recurse(d[childKey])\n        }\n      })\n    }\n\n    recurse(columns)\n\n    return flatColumns\n  }\n\n  // Build the header groups from the bottom up\n  function makeHeaderGroups(columns, maxDepth) {\n    const headerGroups = []\n\n    const removeChildColumns = column => {\n      delete column.columns\n      if (column.parent) {\n        removeChildColumns(column.parent)\n      }\n    }\n    columns.forEach(removeChildColumns)\n\n    const buildGroup = (columns, depth = 0) => {\n      const headerGroup = {\n        headers: []\n      }\n\n      const parentColumns = []\n\n      const hasParents = columns.some(col => col.parent)\n\n      columns.forEach(column => {\n        const isFirst = !parentColumns.length\n        let latestParentColumn = [...parentColumns].reverse()[0]\n\n        // If the column has a parent, add it if necessary\n        if (column.parent) {\n          if (isFirst || latestParentColumn.originalID !== column.parent.id) {\n            parentColumns.push({\n              ...column.parent,\n              originalID: column.parent.id,\n              id: [column.parent.id, parentColumns.length].join('_')\n            })\n          }\n        } else if (hasParents) {\n          // If other columns have parents, add a place holder if necessary\n          const placeholderColumn = decorateColumn({\n            originalID: [column.id, 'placeholder', maxDepth - depth].join('_'),\n            id: [\n              column.id,\n              'placeholder',\n              maxDepth - depth,\n              parentColumns.length\n            ].join('_')\n          })\n          if (\n            isFirst ||\n            latestParentColumn.originalID !== placeholderColumn.originalID\n          ) {\n            parentColumns.push(placeholderColumn)\n          }\n        }\n\n        // Establish the new columns[] relationship on the parent\n        if (column.parent || hasParents) {\n          latestParentColumn = [...parentColumns].reverse()[0]\n          latestParentColumn.columns = latestParentColumn.columns || []\n          if (!latestParentColumn.columns.includes(column)) {\n            latestParentColumn.columns.push(column)\n          }\n        }\n\n        headerGroup.headers.push(column)\n      })\n\n      headerGroups.push(headerGroup)\n\n      if (parentColumns.length) {\n        buildGroup(parentColumns)\n      }\n    }\n\n    buildGroup(columns)\n\n    return headerGroups.reverse()\n  }\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst propTypes = {\n  subRowsKey: PropTypes.string\n}\n\nexport const useRows = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useRows')\n\n  const { debug, columns, subRowsKey = 'subRows', data } = props\n\n  const accessedRows = useMemo(() => {\n    if (debug) console.info('getAccessedRows')\n\n    // Access the row's data\n    const accessRow = (originalRow, i, depth = 0) => {\n      // Keep the original reference around\n      const original = originalRow\n\n      // Process any subRows\n      const subRows = originalRow[subRowsKey]\n        ? originalRow[subRowsKey].map((d, i) => accessRow(d, i, depth + 1))\n        : undefined\n\n      const row = {\n        original,\n        index: i,\n        subRows,\n        depth\n      }\n\n      // Create the cells and values\n      row.values = {}\n      columns.forEach(column => {\n        row.values[column.id] = column.accessor\n          ? column.accessor(originalRow, i, { subRows, depth, data })\n          : undefined\n      })\n\n      return row\n    }\n\n    // Use the resolved data\n    return data.map((d, i) => accessRow(d, i))\n  }, [data, columns])\n\n  return {\n    ...props,\n    rows: accessedRows\n  }\n}\n","const actions = {}\n\nexport { actions }\n\nexport const addActions = acts => {\n  Object.keys(acts).forEach(key => {\n    actions[key] = acts[key]\n  })\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { getBy, getFirstDefined, setBy } from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.expanded = {}\n\naddActions({\n  toggleExpanded: '__toggleExpanded__',\n  useExpanded: '__useExpanded__'\n})\n\nconst propTypes = {\n  expandedKey: PropTypes.string\n}\n\nexport const useExpanded = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useExpanded')\n\n  const {\n    debug,\n    columns,\n    rows,\n    expandedKey = 'expanded',\n    hooks,\n    state: [{ expanded }, setState]\n  } = props\n\n  const toggleExpandedByPath = (path, set) => {\n    return setState(old => {\n      const { expanded } = old\n      const existing = getBy(expanded, path)\n      set = getFirstDefined(set, !existing)\n      return {\n        ...old,\n        expanded: setBy(expanded, path, set)\n      }\n    }, actions.toggleExpanded)\n  }\n\n  hooks.row.push(row => {\n    const { path } = row\n    row.toggleExpanded = set => toggleExpandedByPath(path, set)\n  })\n\n  const expandedRows = useMemo(() => {\n    if (debug) console.info('getExpandedRows')\n\n    const expandedRows = []\n\n    // Here we do some mutation, but it's the last stage in the\n    // immutable process so this is safe\n    const handleRow = (row, index, depth = 0, parentPath = []) => {\n      // Compute some final state for the row\n      const path = [...parentPath, index]\n\n      row.path = path\n      row.depth = depth\n\n      row.isExpanded =\n        (row.original && row.original[expandedKey]) || getBy(expanded, path)\n\n      row.cells = columns.map(column => {\n        const cell = {\n          column,\n          row,\n          state: null,\n          value: row.values[column.id]\n        }\n\n        return cell\n      })\n\n      expandedRows.push(row)\n\n      if (row.isExpanded && row.subRows && row.subRows.length) {\n        row.subRows.forEach((row, i) => handleRow(row, i, depth + 1, path))\n      }\n    }\n\n    rows.forEach((row, i) => handleRow(row, i))\n\n    return expandedRows\n  }, [rows, expanded, columns])\n\n  const expandedDepth = findExpandedDepth(expanded)\n\n  return {\n    ...props,\n    toggleExpandedByPath,\n    expandedDepth,\n    rows: expandedRows\n  }\n}\n\nfunction findExpandedDepth(obj, depth = 1) {\n  return Object.values(obj).reduce((prev, curr) => {\n    if (typeof curr === 'object') {\n      return Math.max(prev, findExpandedDepth(curr, depth + 1))\n    }\n    return depth\n  }, 0)\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { defaultFilterFn, getFirstDefined } from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.filters = {}\naddActions({\n  setFilter: '__setFilter__',\n  setAllFilters: '__setAllFilters__'\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      filterFn: PropTypes.func,\n      filterAll: PropTypes.bool,\n      canFilter: PropTypes.bool,\n      Filter: PropTypes.any\n    })\n  ),\n\n  filterFn: PropTypes.func,\n  manualFilters: PropTypes.bool\n}\n\nexport const useFilters = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useFilters')\n\n  const {\n    debug,\n    rows,\n    columns,\n    filterFn = defaultFilterFn,\n    manualFilters,\n    disableFilters,\n    hooks,\n    state: [{ filters }, setState]\n  } = props\n\n  columns.forEach(column => {\n    const { id, accessor, canFilter } = column\n    column.canFilter = accessor\n      ? getFirstDefined(\n        canFilter,\n        disableFilters === true ? false : undefined,\n        true\n      )\n      : false\n    // Was going to add this to the filter hook\n    column.filterValue = filters[id]\n  })\n\n  const setFilter = (id, val) => {\n    return setState(old => {\n      if (typeof val === 'undefined') {\n        const { [id]: prev, ...rest } = filters\n        return {\n          ...old,\n          filters: {\n            ...rest\n          }\n        }\n      }\n\n      return {\n        ...old,\n        filters: {\n          ...filters,\n          [id]: val\n        }\n      }\n    }, actions.setFilter)\n  }\n\n  const setAllFilters = filters => {\n    return setState(old => {\n      return {\n        ...old,\n        filters\n      }\n    }, actions.setAllFilters)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canFilter) {\n        column.setFilter = val => setFilter(column.id, val)\n      }\n    })\n    return columns\n  })\n\n  const filteredRows = useMemo(() => {\n    if (manualFilters || !Object.keys(filters).length) {\n      return rows\n    }\n\n    if (debug) console.info('getFilteredRows')\n\n    // Filters top level and nested rows\n    const filterRows = rows => {\n      let filteredRows = rows\n\n      filteredRows = Object.entries(filters).reduce(\n        (filteredSoFar, [columnID, filterValue]) => {\n          // Find the filters column\n          const column = columns.find(d => d.id === columnID)\n\n          // Don't filter hidden columns or columns that have had their filters disabled\n          if (!column || column.filterable === false) {\n            return filteredSoFar\n          }\n\n          const filterMethod = column.filterMethod || filterFn\n\n          // If 'filterAll' is set to true, pass the entire dataset to the filter method\n          if (column.filterAll) {\n            return filterMethod(filteredSoFar, columnID, filterValue, column)\n          }\n          return filteredSoFar.filter(row =>\n            filterMethod(row, columnID, filterValue, column)\n          )\n        },\n        rows\n      )\n\n      // Apply the filter to any subRows\n      filteredRows = filteredRows.map(row => {\n        if (!row.subRows) {\n          return row\n        }\n        return {\n          ...row,\n          subRows: filterRows(row.subRows)\n        }\n      })\n\n      // then filter any rows without subcolumns because it would be strange to show\n      filteredRows = filteredRows.filter(row => {\n        if (!row.subRows) {\n          return true\n        }\n        return row.subRows.length > 0\n      })\n\n      return filteredRows\n    }\n\n    return filterRows(rows)\n  }, [rows, filters, manualFilters])\n\n  return {\n    ...props,\n    setFilter,\n    setAllFilters,\n    rows: filteredRows\n  }\n}\n","export function sum(values, rows) {\n  return values.reduce((sum, next) => sum + next, 0)\n}\n\nexport function average(values, rows) {\n  return Math.round((sum(values, rows) / values.length) * 100) / 100\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport * as aggregations from '../aggregations'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\nimport {\n  mergeProps,\n  applyPropHooks,\n  defaultGroupByFn,\n  getFirstDefined\n} from '../utils'\n\ndefaultState.groupBy = []\n\naddActions({\n  toggleGroupBy: '__toggleGroupBy__'\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      aggregate: PropTypes.func,\n      canGroupBy: PropTypes.bool,\n      Aggregated: PropTypes.any\n    })\n  ),\n  groupByFn: PropTypes.func,\n  manualGrouping: PropTypes.bool,\n  aggregations: PropTypes.object\n}\n\nexport const useGroupBy = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useGroupBy')\n\n  const {\n    debug,\n    rows,\n    columns,\n    groupByFn = defaultGroupByFn,\n    manualGroupBy,\n    disableGrouping,\n    aggregations: userAggregations = {},\n    hooks,\n    state: [{ groupBy }, setState]\n  } = props\n\n  columns.forEach(column => {\n    const { id, accessor, canGroupBy } = column\n    column.grouped = groupBy.includes(id)\n\n    column.canGroupBy = accessor\n      ? getFirstDefined(\n        canGroupBy,\n        disableGrouping === true ? false : undefined,\n        true\n      )\n      : false\n\n    column.Aggregated = column.Aggregated || column.Cell\n  })\n\n  const toggleGroupBy = (id, toggle) => {\n    return setState(old => {\n      const resolvedToggle =\n        typeof toggle !== 'undefined' ? toggle : !groupBy.includes(id)\n      if (resolvedToggle) {\n        return {\n          ...old,\n          groupBy: [...groupBy, id]\n        }\n      }\n      return {\n        ...old,\n        groupBy: groupBy.filter(d => d !== id)\n      }\n    }, actions.toggleGroupBy)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canGroupBy) {\n        column.toggleGroupBy = () => toggleGroupBy(column.id)\n      }\n    })\n    return columns\n  })\n\n  hooks.getGroupByToggleProps = []\n\n  const addGroupByToggleProps = (columns, api) => {\n    columns.forEach(column => {\n      const { canGroupBy } = column\n      column.getGroupByToggleProps = props => {\n        return mergeProps(\n          {\n            onClick: canGroupBy\n              ? e => {\n                e.persist()\n                column.toggleGroupBy()\n              }\n              : undefined,\n            style: {\n              cursor: canGroupBy ? 'pointer' : undefined\n            },\n            title: 'Toggle GroupBy'\n          },\n          applyPropHooks(api.hooks.getGroupByToggleProps, column, api),\n          props\n        )\n      }\n    })\n    return columns\n  }\n\n  hooks.columns.push(addGroupByToggleProps)\n  hooks.headers.push(addGroupByToggleProps)\n\n  const groupedRows = useMemo(() => {\n    if (manualGroupBy || !groupBy.length) {\n      return rows\n    }\n    if (debug) console.info('getGroupedRows')\n    // Find the columns that can or are aggregating\n\n    // Uses each column to aggregate rows into a single value\n    const aggregateRowsToValues = rows => {\n      const values = {}\n      columns.forEach(column => {\n        const columnValues = rows.map(d => d.values[column.id])\n        let aggregate =\n          userAggregations[column.aggregate] ||\n          aggregations[column.aggregate] ||\n          column.aggregate\n        if (typeof aggregate === 'function') {\n          values[column.id] = aggregate(columnValues, rows)\n        } else if (aggregate) {\n          throw new Error(\n            `Invalid aggregate \"${aggregate}\" passed to column with ID: \"${\n              column.id\n            }\"`\n          )\n        } else {\n          values[column.id] = columnValues[0]\n        }\n      })\n      return values\n    }\n\n    // Recursively group the data\n    const groupRecursively = (rows, groupBy, depth = 0) => {\n      // This is the last level, just return the rows\n      if (depth >= groupBy.length) {\n        return rows\n      }\n\n      // Group the rows together for this level\n      let groupedRows = Object.entries(groupByFn(rows, groupBy[depth])).map(\n        ([groupByVal, subRows], index) => {\n          // Recurse to sub rows before aggregation\n          subRows = groupRecursively(subRows, groupBy, depth + 1)\n\n          const values = aggregateRowsToValues(subRows)\n\n          const row = {\n            groupByID: groupBy[depth],\n            groupByVal,\n            values,\n            subRows,\n            depth,\n            index\n          }\n          return row\n        }\n      )\n\n      return groupedRows\n    }\n\n    // Assign the new data\n    return groupRecursively(rows, groupBy)\n  }, [rows, groupBy, columns, manualGroupBy])\n\n  return {\n    ...props,\n    rows: groupedRows\n  }\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\nimport {\n  mergeProps,\n  applyPropHooks,\n  getFirstDefined,\n  defaultOrderByFn,\n  defaultSortByFn\n} from '../utils'\n\ndefaultState.sortBy = []\n\naddActions({\n  sortByChange: '__sortByChange__'\n})\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      sortByFn: PropTypes.func,\n      efaultSortDesc: PropTypes.bool\n    })\n  ),\n  sortByFn: PropTypes.func,\n  manualSorting: PropTypes.bool,\n  disableSorting: PropTypes.bool,\n  defaultSortDesc: PropTypes.bool,\n  disableMultiSort: PropTypes.bool\n}\n\nexport const useSortBy = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useSortBy')\n\n  const {\n    debug,\n    rows,\n    columns,\n    orderByFn = defaultOrderByFn,\n    sortByFn = defaultSortByFn,\n    manualSorting,\n    disableSorting,\n    defaultSortDesc,\n    hooks,\n    state: [{ sortBy }, setState]\n  } = props\n\n  columns.forEach(column => {\n    const { accessor, canSortBy } = column\n    column.canSortBy = accessor\n      ? getFirstDefined(\n        canSortBy,\n        disableSorting === true ? false : undefined,\n        true\n      )\n      : false\n  })\n\n  // Updates sorting based on a columnID, desc flag and multi flag\n  const toggleSortByID = (columnID, desc, multi) => {\n    return setState(old => {\n      const { sortBy } = old\n\n      // Find the column for this columnID\n      const column = columns.find(d => d.id === columnID)\n      const resolvedDefaultSortDesc = getFirstDefined(\n        column.defaultSortDesc,\n        defaultSortDesc\n      )\n\n      // Find any existing sortBy for this column\n      const existingSortBy = sortBy.find(d => d.id === columnID)\n      const hasDescDefined = typeof desc !== 'undefined' && desc !== null\n\n      let newSortBy = []\n\n      // What should we do with this filter?\n      let action\n\n      if (!multi) {\n        if (sortBy.length <= 1 && existingSortBy) {\n          if (existingSortBy.desc) {\n            action = 'remove'\n          } else {\n            action = 'toggle'\n          }\n        } else {\n          action = 'replace'\n        }\n      } else {\n        if (!existingSortBy) {\n          action = 'add'\n        } else {\n          if (hasDescDefined) {\n            action = 'set'\n          } else {\n            action = 'toggle'\n          }\n        }\n      }\n\n      if (action === 'replace') {\n        newSortBy = [\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : resolvedDefaultSortDesc\n          }\n        ]\n      } else if (action === 'add') {\n        newSortBy = [\n          ...sortBy,\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : resolvedDefaultSortDesc\n          }\n        ]\n      } else if (action === 'set') {\n        newSortBy = sortBy.map(d => {\n          if (d.id === columnID) {\n            return {\n              ...d,\n              desc\n            }\n          }\n          return d\n        })\n      } else if (action === 'toggle') {\n        newSortBy = sortBy.map(d => {\n          if (d.id === columnID) {\n            return {\n              ...d,\n              desc: !existingSortBy.desc\n            }\n          }\n          return d\n        })\n      } else if (action === 'remove') {\n        newSortBy = []\n      }\n\n      return {\n        ...old,\n        sortBy: newSortBy\n      }\n    }, actions.sortByChange)\n  }\n\n  hooks.columns.push(columns => {\n    columns.forEach(column => {\n      if (column.canSortBy) {\n        column.toggleSortBy = (desc, multi) =>\n          toggleSortByID(column.id, desc, multi)\n      }\n    })\n    return columns\n  })\n\n  hooks.getSortByToggleProps = []\n\n  const addSortByToggleProps = (columns, api) => {\n    columns.forEach(column => {\n      const { canSortBy } = column\n      column.getSortByToggleProps = props => {\n        return mergeProps(\n          {\n            onClick: canSortBy\n              ? e => {\n                e.persist()\n                column.toggleSortBy(\n                  undefined,\n                  !api.disableMultiSort && e.shiftKey\n                )\n              }\n              : undefined,\n            style: {\n              cursor: canSortBy ? 'pointer' : undefined\n            },\n            title: 'Toggle SortBy'\n          },\n          applyPropHooks(api.hooks.getSortByToggleProps, column, api),\n          props\n        )\n      }\n    })\n    return columns\n  }\n\n  hooks.columns.push(addSortByToggleProps)\n  hooks.headers.push(addSortByToggleProps)\n\n  // Mutate columns to reflect sorting state\n  columns.forEach(column => {\n    const { id } = column\n    column.sorted = sortBy.find(d => d.id === id)\n    column.sortedIndex = sortBy.findIndex(d => d.id === id)\n    column.sortedDesc = column.sorted ? column.sorted.desc : undefined\n  })\n\n  const sortedRows = useMemo(() => {\n    if (manualSorting || !sortBy.length) {\n      return rows\n    }\n    if (debug) console.info('getSortedRows')\n\n    const sortMethodsByColumnID = {}\n\n    columns\n      .filter(col => col.sortMethod)\n      .forEach(col => {\n        sortMethodsByColumnID[col.id] = col.sortMethod\n      })\n\n    const sortData = rows => {\n      // Use the orderByFn to compose multiple sortBy's together.\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = orderByFn(\n        rows,\n        sortBy.map(sort => {\n          // Support custom sorting methods for each column\n          const columnSortBy = sortMethodsByColumnID[sort.id]\n\n          // Return the correct sortFn\n          return (a, b) =>\n            (columnSortBy || sortByFn)(\n              a.values[sort.id],\n              b.values[sort.id],\n              sort.desc\n            )\n        }),\n        // Map the directions\n        sortBy.map(d => !d.desc)\n      )\n\n      // TODO: this should be optimized. Not good to loop again\n      sortedData.forEach(row => {\n        if (!row.subRows) {\n          return\n        }\n        row.subRows = sortData(row.subRows)\n      })\n\n      return sortedData\n    }\n\n    return sortData(rows)\n  }, [rows, columns, sortBy, manualSorting])\n\n  return {\n    ...props,\n    rows: sortedRows\n  }\n}\n","import { useMemo, useLayoutEffect } from 'react'\nimport PropTypes from 'prop-types'\n\n//\nimport { addActions, actions } from '../actions'\nimport { defaultState } from './useTableState'\n\ndefaultState.pageSize = 10\ndefaultState.pageIndex = 0\n\naddActions({\n  pageChange: '__pageChange__'\n})\n\nconst propTypes = {\n  // General\n  manualPagination: PropTypes.bool\n}\n\nexport const usePagination = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'usePagination')\n\n  const {\n    rows,\n    manualPagination,\n    debug,\n    state: [\n      {\n        pageSize,\n        pageIndex,\n        pageCount: userPageCount,\n        filters,\n        groupBy,\n        sortBy\n      },\n      setState\n    ]\n  } = props\n\n  useLayoutEffect(() => {\n    setState(\n      old => ({\n        ...old,\n        pageIndex: 0\n      }),\n      actions.pageChange\n    )\n  }, [filters, groupBy, sortBy])\n\n  const { pages, pageCount } = useMemo(() => {\n    if (manualPagination) {\n      return {\n        pages: [rows],\n        pageCount: userPageCount\n      }\n    }\n    if (debug) console.info('getPages')\n\n    // Create a new pages with the first page ready to go.\n    const pages = rows.length ? [] : [[]]\n\n    // Start the pageIndex and currentPage cursors\n    let cursor = 0\n    while (cursor < rows.length) {\n      const end = cursor + pageSize\n      pages.push(rows.slice(cursor, end))\n      cursor = end\n    }\n\n    const pageCount = pages.length\n\n    return {\n      pages,\n      pageCount,\n      pageOptions\n    }\n  }, [rows, pageSize, userPageCount])\n\n  const pageOptions = [...new Array(pageCount)].map((d, i) => i)\n  const page = manualPagination ? rows : pages[pageIndex] || []\n  const canPreviousPage = pageIndex > 0\n  const canNextPage = pageIndex < pageCount - 1\n\n  const gotoPage = pageIndex => {\n    if (debug) console.info('gotoPage')\n    return setState(old => {\n      if (pageIndex < 0 || pageIndex > pageCount - 1) {\n        return old\n      }\n      return {\n        ...old,\n        pageIndex\n      }\n    }, actions.pageChange)\n  }\n\n  const previousPage = () => {\n    return gotoPage(pageIndex - 1)\n  }\n\n  const nextPage = () => {\n    return gotoPage(pageIndex + 1)\n  }\n\n  const setPageSize = pageSize => {\n    setState(old => {\n      const topRowIndex = old.pageSize * old.pageIndex\n      const pageIndex = Math.floor(topRowIndex / pageSize)\n      return {\n        ...old,\n        pageIndex,\n        pageSize\n      }\n    }, actions.setPageSize)\n  }\n\n  return {\n    ...props,\n    pages,\n    pageOptions,\n    page,\n    canPreviousPage,\n    canNextPage,\n    gotoPage,\n    previousPage,\n    nextPage,\n    setPageSize\n  }\n}\n","import PropTypes from 'prop-types'\n\nimport { getFirstDefined, sum } from '../utils'\n\nexport const actions = {}\n\nconst propTypes = {\n  defaultFlex: PropTypes.number\n}\n\nexport const useFlexLayout = props => {\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useFlexLayout')\n\n  const {\n    defaultFlex = 1,\n    hooks: {\n      columns: columnsHooks,\n      getRowProps,\n      getHeaderRowProps,\n      getHeaderProps,\n      getCellProps\n    }\n  } = props\n\n  columnsHooks.push((columns, api) => {\n    const visibleColumns = columns.filter(column => {\n      column.visible =\n        typeof column.show === 'function' ? column.show(api) : !!column.show\n      return column.visible\n    })\n\n    const columnMeasurements = {}\n\n    let sumWidth = 0\n    visibleColumns.forEach(column => {\n      const { width, minWidth } = getSizesForColumn(\n        column,\n        defaultFlex,\n        undefined,\n        undefined,\n        api\n      )\n      if (width) {\n        sumWidth += width\n      } else if (minWidth) {\n        sumWidth += minWidth\n      } else {\n        sumWidth += defaultFlex\n      }\n    })\n\n    const rowStyles = {\n      style: {\n        display: 'flex',\n        minWidth: `${sumWidth}px`\n      }\n    }\n\n    api.rowStyles = rowStyles\n\n    getRowProps.push(() => rowStyles)\n    getHeaderRowProps.push(() => rowStyles)\n\n    getHeaderProps.push(column => ({\n      style: {\n        boxSizing: 'border-box',\n        ...getStylesForColumn(column, columnMeasurements, defaultFlex, api)\n      }\n      // [refKey]: el => {\n      //   renderedCellInfoRef.current[key] = {\n      //     column,\n      //     el\n      //   };\n      // },\n    }))\n\n    getCellProps.push(cell => {\n      return {\n        style: {\n          display: 'block',\n          boxSizing: 'border-box',\n          ...getStylesForColumn(\n            cell.column,\n            columnMeasurements,\n            defaultFlex,\n            undefined,\n            api\n          )\n        }\n        // [refKey]: el => {\n        //   renderedCellInfoRef.current[columnPathStr] = {\n        //     column,\n        //     el\n        //   };\n        // }\n      }\n    })\n\n    return columns\n  })\n\n  return props\n}\n\n// Utils\n\nfunction getStylesForColumn(column, columnMeasurements, defaultFlex, api) {\n  const { flex, width, maxWidth } = getSizesForColumn(\n    column,\n    columnMeasurements,\n    defaultFlex,\n    api\n  )\n\n  return {\n    flex: `${flex} 0 auto`,\n    width: `${width}px`,\n    maxWidth: `${maxWidth}px`\n  }\n}\n\nfunction getSizesForColumn(\n  { columns, id, width, minWidth, maxWidth },\n  columnMeasurements,\n  defaultFlex,\n  api\n) {\n  if (columns) {\n    columns = columns\n      .map(column =>\n        getSizesForColumn(column, columnMeasurements, defaultFlex, api)\n      )\n      .filter(Boolean)\n\n    if (!columns.length) {\n      return false\n    }\n\n    const flex = sum(columns.map(col => col.flex))\n    const width = sum(columns.map(col => col.width))\n    const maxWidth = sum(columns.map(col => col.maxWidth))\n\n    return {\n      flex,\n      width,\n      maxWidth\n    }\n  }\n\n  return {\n    flex: width ? 0 : defaultFlex,\n    width:\n      width === 'auto'\n        ? columnMeasurements[id] || defaultFlex\n        : getFirstDefined(width, minWidth, defaultFlex),\n    maxWidth\n  }\n}\n\n// const resetRefs = () => {\n//   if (debug) console.info(\"resetRefs\");\n//   renderedCellInfoRef.current = {};\n// };\n\n// const calculateAutoWidths = () => {\n//   RAF(() => {\n//     const newColumnMeasurements = {};\n//     Object.values(renderedCellInfoRef.current).forEach(({ column, el }) => {\n//       if (!el) {\n//         return;\n//       }\n\n//       let measurement = 0;\n\n//       const measureChildren = children => {\n//         if (children) {\n//           [].slice.call(children).forEach(child => {\n//             measurement = Math.max(\n//               measurement,\n//               Math.ceil(child.offsetWidth) || 0\n//             );\n//             measureChildren(child.children);\n//           });\n//         }\n//         return measurement;\n//       };\n\n//       const parentDims = getElementDimensions(el);\n//       measureChildren(el.children);\n\n//       newColumnMeasurements[column.id] = Math.max(\n//         newColumnMeasurements[column.id] || 0,\n//         measurement + parentDims.paddingLeft + parentDims.paddingRight\n//       );\n//     });\n\n//     const oldKeys = Object.keys(columnMeasurements);\n//     const newKeys = Object.keys(newColumnMeasurements);\n\n//     const needsUpdate =\n//       oldKeys.length !== newKeys.length ||\n//       oldKeys.some(key => {\n//         return columnMeasurements[key] !== newColumnMeasurements[key];\n//       });\n\n//     if (needsUpdate) {\n//       setState(old => {\n//         return {\n//           ...old,\n//           columnMeasurements: newColumnMeasurements\n//         };\n//       }, actions.updateAutoWidth);\n//     }\n//   });\n// };\n","import { useState } from 'react'\n\n// Token pagination behaves a bit differently from\n// index based pagination. This hook aids in that process.\n\nexport const useTokenPagination = () => {\n  const [pageToken, setPageToken] = useState()\n  const [nextPageToken, setNextPageToken] = useState()\n  const [previousPageTokens, setPreviousPageTokens] = useState([])\n  const [pageIndex, setPageIndex] = useState(0)\n\n  // Since we're using pagination tokens intead of index, we need\n  // to be a bit clever with page-like navigation here.\n  const nextPage = () => {\n    setPageIndex(old => old + 1)\n    setPreviousPageTokens(old => [...old, pageToken])\n    setPageToken(nextPageToken)\n  }\n\n  const previousPage = () => {\n    setPageIndex(old => old - 1)\n    setPreviousPageTokens(old =>\n      [...old]\n        .reverse()\n        .slice(1)\n        .reverse()\n    )\n    setPageToken(previousPageTokens[previousPageTokens.length - 1])\n  }\n\n  const resetPagination = () => {\n    setPageToken(undefined)\n    setPageIndex(0)\n    setNextPageToken(undefined)\n    setPreviousPageTokens([])\n  }\n\n  const canPreviousPage = previousPageTokens.length\n  const canNextPage = nextPageToken\n\n  return {\n    setNextPageToken,\n    pageToken,\n    pageIndex,\n    previousPage,\n    nextPage,\n    canPreviousPage,\n    canNextPage,\n    resetPagination\n  }\n}\n"],"names":["getBy","obj","path","def","val","pathObj","makePathArray","reduce","cursor","pathPart","e","defaultOrderByFn","arr","funcs","dirs","_toConsumableArray","sort","rowA","rowB","i","length","sortFn","desc","sortInt","index","defaultSortByFn","a","b","toLowerCase","getFirstDefined","arguments","defaultGroupByFn","rows","grouper","prev","row","resKey","values","Array","isArray","push","defaultFilterFn","id","value","column","undefined","String","includes","setBy","recurse","depth","key","target","_typeof","flexRender","Comp","props","Object","getPrototypeOf","isReactComponent","React","mergeProps","groups","forEach","style","className","rest","filter","Boolean","join","applyHooks","hooks","initial","args","next","applyPropHooks","sum","curr","flattenDeep","replace","split","newArr","defaultState","defaultReducer","old","newState","useTableState","initialState","overrides","reducer","useState","state","setState","console","log","useMemo","keys","updater","type","renderErr","propTypes","data","PropTypes","array","isRequired","defaults","object","debug","bool","useTable","checkPropTypes","process","env","NODE_ENV","api","beforeRender","columns","headers","headerGroups","renderableRows","getTableProps","getRowProps","getHeaderRowProps","getHeaderProps","getCellProps","time","plugins","timeEnd","render","userProps","Error","headerGroup","header","visible","prepareRow","cells","cell","columnPathStr","arrayOf","shape","Cell","any","Header","useColumns","userColumns","groupBy","info","columnTree","decorateColumnTree","parent","map","decorateColumn","flattenBy","maxDepth","removeChildColumns","buildGroup","parentColumns","hasParents","some","col","isFirst","latestParentColumn","reverse","originalID","placeholderColumn","makeHeaderGroups","g","find","findMaxDepth","Math","max","accessor","accessorString","error","show","childKey","flatColumns","d","subRowsKey","string","useRows","accessRow","originalRow","original","subRows","actions","addActions","acts","expanded","toggleExpanded","useExpanded","expandedKey","toggleExpandedByPath","set","existing","expandedRows","handleRow","parentPath","isExpanded","expandedDepth","findExpandedDepth","filters","setFilter","setAllFilters","filterFn","func","filterAll","canFilter","Filter","manualFilters","useFilters","disableFilters","filterValue","filteredRows","filterRows","entries","filteredSoFar","columnID","filterable","filterMethod","average","round","toggleGroupBy","aggregate","canGroupBy","Aggregated","groupByFn","manualGrouping","aggregations","useGroupBy","manualGroupBy","disableGrouping","userAggregations","grouped","toggle","getGroupByToggleProps","addGroupByToggleProps","onClick","persist","title","groupRecursively","groupByVal","columnValues","groupByID","sortBy","sortByChange","sortByFn","efaultSortDesc","manualSorting","disableSorting","defaultSortDesc","disableMultiSort","useSortBy","orderByFn","canSortBy","toggleSortBy","multi","action","resolvedDefaultSortDesc","existingSortBy","hasDescDefined","newSortBy","getSortByToggleProps","addSortByToggleProps","shiftKey","sorted","sortedIndex","findIndex","sortedDesc","sortMethodsByColumnID","sortMethod","sortData","sortedData","columnSortBy","pageSize","pageIndex","pageChange","manualPagination","usePagination","userPageCount","pageCount","useLayoutEffect","pages","end","slice","pageOptions","page","gotoPage","canPreviousPage","canNextPage","previousPage","nextPage","setPageSize","topRowIndex","floor","defaultFlex","number","useFlexLayout","columnsHooks","visibleColumns","columnMeasurements","sumWidth","getSizesForColumn","width","minWidth","rowStyles","display","boxSizing","getStylesForColumn","flex","maxWidth","useTokenPagination","pageToken","setPageToken","nextPageToken","setNextPageToken","previousPageTokens","setPreviousPageTokens","setPageIndex","resetPagination"],"mappings":"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"}